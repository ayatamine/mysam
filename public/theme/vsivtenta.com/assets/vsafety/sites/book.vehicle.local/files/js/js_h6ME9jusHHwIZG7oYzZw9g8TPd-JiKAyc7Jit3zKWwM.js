/**
 * DO NOT EDIT THIS FILE.
 * See the following change record for more information,
 * https://www.drupal.org/node/2815083
 * @preserve
 **/
(function($, Drupal) {
    Drupal.theme.progressBar = function(id) {
        return "<div id=\"".concat(id, "\" class=\"progress\" aria-live=\"polite\">") + '<div class="progress__label">&nbsp;</div>' + '<div class="progress__track"><div class="progress__bar"></div></div>' + '<div class="progress__percentage"></div>' + '<div class="progress__description">&nbsp;</div>' + '</div>';
    };
    Drupal.ProgressBar = function(id, updateCallback, method, errorCallback) {
        this.id = id;
        this.method = method || 'GET';
        this.updateCallback = updateCallback;
        this.errorCallback = errorCallback;
        this.element = $(Drupal.theme('progressBar', id));
    };
    $.extend(Drupal.ProgressBar.prototype, {
        setProgress: function setProgress(percentage, message, label) {
            if (percentage >= 0 && percentage <= 100) {
                $(this.element).find('div.progress__bar').css('width', "".concat(percentage, "%"));
                $(this.element).find('div.progress__percentage').html("".concat(percentage, "%"));
            }
            $('div.progress__description', this.element).html(message);
            $('div.progress__label', this.element).html(label);
            if (this.updateCallback) {
                this.updateCallback(percentage, message, this);
            }
        },
        startMonitoring: function startMonitoring(uri, delay) {
            this.delay = delay;
            this.uri = uri;
            this.sendPing();
        },
        stopMonitoring: function stopMonitoring() {
            clearTimeout(this.timer);
            this.uri = null;
        },
        sendPing: function sendPing() {
            if (this.timer) {
                clearTimeout(this.timer);
            }
            if (this.uri) {
                var pb = this;
                var uri = this.uri;
                if (uri.indexOf('?') === -1) {
                    uri += '?';
                } else {
                    uri += '&';
                }
                uri += '_format=json';
                $.ajax({
                    type: this.method,
                    url: uri,
                    data: '',
                    dataType: 'json',
                    success: function success(progress) {
                        if (progress.status === 0) {
                            pb.displayError(progress.data);
                            return;
                        }
                        pb.setProgress(progress.percentage, progress.message, progress.label);
                        pb.timer = setTimeout(function() {
                            pb.sendPing();
                        }, pb.delay);
                    },
                    error: function error(xmlhttp) {
                        var e = new Drupal.AjaxError(xmlhttp, pb.uri);
                        pb.displayError("<pre>".concat(e.message, "</pre>"));
                    }
                });
            }
        },
        displayError: function displayError(string) {
            var error = $('<div class="messages messages--error"></div>').html(string);
            $(this.element).before(error).hide();
            if (this.errorCallback) {
                this.errorCallback(this);
            }
        }
    });
})(jQuery, Drupal);;
/**
 * @file
 * Extends methods from core/misc/progress.js.
 */

(function($, Drupal) {

    'use strict';

    /**
     * Theme function for the progress bar.
     *
     * @param {string} id
     *
     * @return {string}
     *   The HTML for the progress bar.
     */
    Drupal.theme.progressBar = function(id) {
        return '<div class="progress-wrapper" aria-live="polite">' +
            '<div class="message"></div>' +
            '<div id ="' + id + '" class="progress progress-striped active">' +
            '<div class="progress-bar" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">' +
            '<span class="percentage"></span>' +
            '</div>' +
            '</div>' +
            '<div class="progress-label"></div>' +
            '</div>';
    };

    $.extend(Drupal.ProgressBar.prototype, /** @lends Drupal.ProgressBar */ {

        /**
         * Set the percentage and status message for the progressbar.
         *
         * @param {number} percentage
         * @param {string} message
         * @param {string} label
         */
        setProgress: function(percentage, message, label) {
            if (percentage >= 0 && percentage <= 100) {
                $(this.element).find('.progress-bar').css('width', percentage + '%').attr('aria-valuenow', percentage);
                $(this.element).find('.percentage').html(percentage + '%');
            }
            if (message) {
                // Remove the unnecessary whitespace at the end of the message.
                message = message.replace(/<br\/>&nbsp;|\s*$/, '');

                $('.message', this.element).html(message);
            }
            if (label) {
                $('.progress-label', this.element).html(label);
            }
            if (this.updateCallback) {
                this.updateCallback(percentage, message, this);
            }
        },

        /**
         * Display errors on the page.
         *
         * @param {string} string
         */
        displayError: function(string) {
            var error = $('<div class="alert alert-block alert-error"><button class="close" data-dismiss="alert">&times;</button><h4>' + Drupal.t('Error message') + '</h4></div>').append(string);
            $(this.element).before(error).hide();

            if (this.errorCallback) {
                this.errorCallback(this);
            }
        }
    });

})(jQuery, Drupal);;
loadjs = function() {
    var h = function() {},
        c = {},
        u = {},
        f = {};

    function o(e, n) {
        if (e) {
            var r = f[e];
            if (u[e] = n, r)
                for (; r.length;) r[0](e, n), r.splice(0, 1)
        }
    }

    function l(e, n) {
        e.call && (e = {
            success: e
        }), n.length ? (e.error || h)(n) : (e.success || h)(e)
    }

    function d(r, t, s, i) {
        var c, o, e = document,
            n = s.async,
            u = (s.numRetries || 0) + 1,
            f = s.before || h,
            l = r.replace(/[\?|#].*$/, ""),
            a = r.replace(/^(css|img)!/, "");
        i = i || 0, /(^css!|\.css$)/.test(l) ? ((o = e.createElement("link")).rel = "stylesheet", o.href = a, (c = "hideFocus" in o) && o.relList && (c = 0, o.rel = "preload", o.as = "style")) : /(^img!|\.(png|gif|jpg|svg|webp)$)/.test(l) ? (o = e.createElement("img")).src = a : ((o = e.createElement("script")).src = r, o.async = void 0 === n || n), !(o.onload = o.onerror = o.onbeforeload = function(e) {
            var n = e.type[0];
            if (c) try {
                o.sheet.cssText.length || (n = "e")
            } catch (e) {
                18 != e.code && (n = "e")
            }
            if ("e" == n) {
                if ((i += 1) < u) return d(r, t, s, i)
            } else if ("preload" == o.rel && "style" == o.as) return o.rel = "stylesheet";
            t(r, n, e.defaultPrevented)
        }) !== f(r, o) && e.head.appendChild(o)
    }

    function r(e, n, r) {
        var t, s;
        if (n && n.trim && (t = n), s = (t ? r : n) || {}, t) {
            if (t in c) throw "LoadJS";
            c[t] = !0
        }

        function i(n, r) {
            ! function(e, t, n) {
                var r, s, i = (e = e.push ? e : [e]).length,
                    c = i,
                    o = [];
                for (r = function(e, n, r) {
                        if ("e" == n && o.push(e), "b" == n) {
                            if (!r) return;
                            o.push(e)
                        }--i || t(o)
                    }, s = 0; s < c; s++) d(e[s], r, n)
            }(e, function(e) {
                l(s, e), n && l({
                    success: n,
                    error: r
                }, e), o(t, e)
            }, s)
        }
        if (s.returnPromise) return new Promise(i);
        i()
    }
    return r.ready = function(e, n) {
        return function(e, r) {
            e = e.push ? e : [e];
            var n, t, s, i = [],
                c = e.length,
                o = c;
            for (n = function(e, n) {
                    n.length && i.push(e), --o || r(i)
                }; c--;) t = e[c], (s = u[t]) ? n(t, s) : (f[t] = f[t] || []).push(n)
        }(e, function(e) {
            l(n, e)
        }), r
    }, r.done = function(e) {
        o(e, [])
    }, r.reset = function() {
        c = {}, u = {}, f = {}
    }, r.isDefined = function(e) {
        return e in c
    }, r
}();;
/**
 * DO NOT EDIT THIS FILE.
 * See the following change record for more information,
 * https://www.drupal.org/node/2815083
 * @preserve
 **/
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
    }
    return arr2;
}
(function($, window, Drupal, drupalSettings, loadjs, _ref) {
    var isFocusable = _ref.isFocusable,
        tabbable = _ref.tabbable;
    Drupal.behaviors.AJAX = {
        attach: function attach(context, settings) {
            function loadAjaxBehavior(base) {
                var elementSettings = settings.ajax[base];
                if (typeof elementSettings.selector === 'undefined') {
                    elementSettings.selector = "#".concat(base);
                }
                once('drupal-ajax', $(elementSettings.selector)).forEach(function(el) {
                    elementSettings.element = el;
                    elementSettings.base = base;
                    Drupal.ajax(elementSettings);
                });
            }
            Object.keys(settings.ajax || {}).forEach(function(base) {
                return loadAjaxBehavior(base);
            });
            Drupal.ajax.bindAjaxLinks(document.body);
            once('ajax', '.use-ajax-submit').forEach(function(el) {
                var elementSettings = {};
                elementSettings.url = $(el.form).attr('action');
                elementSettings.setClick = true;
                elementSettings.event = 'click';
                elementSettings.progress = {
                    type: 'throbber'
                };
                elementSettings.base = el.id;
                elementSettings.element = el;
                Drupal.ajax(elementSettings);
            });
        },
        detach: function detach(context, settings, trigger) {
            if (trigger === 'unload') {
                Drupal.ajax.expired().forEach(function(instance) {
                    Drupal.ajax.instances[instance.instanceIndex] = null;
                });
            }
        }
    };
    Drupal.AjaxError = function(xmlhttp, uri, customMessage) {
        var statusCode;
        var statusText;
        var responseText;
        if (xmlhttp.status) {
            statusCode = "\n".concat(Drupal.t('An AJAX HTTP error occurred.'), "\n").concat(Drupal.t('HTTP Result Code: !status', {
                '!status': xmlhttp.status
            }));
        } else {
            statusCode = "\n".concat(Drupal.t('An AJAX HTTP request terminated abnormally.'));
        }
        statusCode += "\n".concat(Drupal.t('Debugging information follows.'));
        var pathText = "\n".concat(Drupal.t('Path: !uri', {
            '!uri': uri
        }));
        statusText = '';
        try {
            statusText = "\n".concat(Drupal.t('StatusText: !statusText', {
                '!statusText': xmlhttp.statusText.trim()
            }));
        } catch (e) {}
        responseText = '';
        try {
            responseText = "\n".concat(Drupal.t('ResponseText: !responseText', {
                '!responseText': xmlhttp.responseText.trim()
            }));
        } catch (e) {}
        responseText = responseText.replace(/<("[^"]*"|'[^']*'|[^'">])*>/gi, '');
        responseText = responseText.replace(/[\n]+\s+/g, '\n');
        var readyStateText = xmlhttp.status === 0 ? "\n".concat(Drupal.t('ReadyState: !readyState', {
            '!readyState': xmlhttp.readyState
        })) : '';
        customMessage = customMessage ? "\n".concat(Drupal.t('CustomMessage: !customMessage', {
            '!customMessage': customMessage
        })) : '';
        this.message = statusCode + pathText + statusText + customMessage + responseText + readyStateText;
        this.name = 'AjaxError';
    };
    Drupal.AjaxError.prototype = new Error();
    Drupal.AjaxError.prototype.constructor = Drupal.AjaxError;
    Drupal.ajax = function(settings) {
        if (arguments.length !== 1) {
            throw new Error('Drupal.ajax() function must be called with one configuration object only');
        }
        var base = settings.base || false;
        var element = settings.element || false;
        delete settings.base;
        delete settings.element;
        if (!settings.progress && !element) {
            settings.progress = false;
        }
        var ajax = new Drupal.Ajax(base, element, settings);
        ajax.instanceIndex = Drupal.ajax.instances.length;
        Drupal.ajax.instances.push(ajax);
        return ajax;
    };
    Drupal.ajax.instances = [];
    Drupal.ajax.expired = function() {
        return Drupal.ajax.instances.filter(function(instance) {
            return instance && instance.element !== false && !document.body.contains(instance.element);
        });
    };
    Drupal.ajax.bindAjaxLinks = function(element) {
        once('ajax', '.use-ajax', element).forEach(function(ajaxLink) {
            var $linkElement = $(ajaxLink);
            var elementSettings = {
                progress: {
                    type: 'throbber'
                },
                dialogType: $linkElement.data('dialog-type'),
                dialog: $linkElement.data('dialog-options'),
                dialogRenderer: $linkElement.data('dialog-renderer'),
                base: $linkElement.attr('id'),
                element: ajaxLink
            };
            var href = $linkElement.attr('href');
            if (href) {
                elementSettings.url = href;
                elementSettings.event = 'click';
            }
            Drupal.ajax(elementSettings);
        });
    };
    Drupal.Ajax = function(base, element, elementSettings) {
        var defaults = {
            event: element ? 'mousedown' : null,
            keypress: true,
            selector: base ? "#".concat(base) : null,
            effect: 'none',
            speed: 'none',
            method: 'replaceWith',
            progress: {
                type: 'throbber',
                message: Drupal.t('Please wait...')
            },
            submit: {
                js: true
            }
        };
        $.extend(this, defaults, elementSettings);
        this.commands = new Drupal.AjaxCommands();
        this.instanceIndex = false;
        if (this.wrapper) {
            this.wrapper = "#".concat(this.wrapper);
        }
        this.element = element;
        this.element_settings = elementSettings;
        this.elementSettings = elementSettings;
        if (this.element && this.element.form) {
            this.$form = $(this.element.form);
        }
        if (!this.url) {
            var $element = $(this.element);
            if ($element.is('a')) {
                this.url = $element.attr('href');
            } else if (this.element && element.form) {
                this.url = this.$form.attr('action');
            }
        }
        var originalUrl = this.url;
        this.url = this.url.replace(/\/nojs(\/|$|\?|#)/, '/ajax$1');
        if (drupalSettings.ajaxTrustedUrl[originalUrl]) {
            drupalSettings.ajaxTrustedUrl[this.url] = true;
        }
        var ajax = this;
        ajax.options = {
            url: ajax.url,
            data: ajax.submit,
            isInProgress: function isInProgress() {
                return ajax.ajaxing;
            },
            beforeSerialize: function beforeSerialize(elementSettings, options) {
                return ajax.beforeSerialize(elementSettings, options);
            },
            beforeSubmit: function beforeSubmit(formValues, elementSettings, options) {
                ajax.ajaxing = true;
                return ajax.beforeSubmit(formValues, elementSettings, options);
            },
            beforeSend: function beforeSend(xmlhttprequest, options) {
                ajax.ajaxing = true;
                return ajax.beforeSend(xmlhttprequest, options);
            },
            success: function success(response, status, xmlhttprequest) {
                var _this = this;
                if (typeof response === 'string') {
                    response = $.parseJSON(response);
                }
                if (response !== null && !drupalSettings.ajaxTrustedUrl[ajax.url]) {
                    if (xmlhttprequest.getResponseHeader('X-Drupal-Ajax-Token') !== '1') {
                        var customMessage = Drupal.t('The response failed verification so will not be processed.');
                        return ajax.error(xmlhttprequest, ajax.url, customMessage);
                    }
                }
                return Promise.resolve(ajax.success(response, status)).then(function() {
                    ajax.ajaxing = false;
                    $(document).trigger('ajaxSuccess', [xmlhttprequest, _this]);
                    $(document).trigger('ajaxComplete', [xmlhttprequest, _this]);
                    if (--$.active === 0) {
                        $(document).trigger('ajaxStop');
                    }
                });
            },
            error: function error(xmlhttprequest, status, _error) {
                ajax.ajaxing = false;
            },
            complete: function complete(xmlhttprequest, status) {
                if (status === 'error' || status === 'parsererror') {
                    return ajax.error(xmlhttprequest, ajax.url);
                }
            },
            dataType: 'json',
            jsonp: false,
            type: 'POST'
        };
        if (elementSettings.dialog) {
            ajax.options.data.dialogOptions = elementSettings.dialog;
        }
        if (ajax.options.url.indexOf('?') === -1) {
            ajax.options.url += '?';
        } else {
            ajax.options.url += '&';
        }
        var wrapper = "drupal_".concat(elementSettings.dialogType || 'ajax');
        if (elementSettings.dialogRenderer) {
            wrapper += ".".concat(elementSettings.dialogRenderer);
        }
        ajax.options.url += "".concat(Drupal.ajax.WRAPPER_FORMAT, "=").concat(wrapper);
        $(ajax.element).on(elementSettings.event, function(event) {
            if (!drupalSettings.ajaxTrustedUrl[ajax.url] && !Drupal.url.isLocal(ajax.url)) {
                throw new Error(Drupal.t('The callback URL is not local and not trusted: !url', {
                    '!url': ajax.url
                }));
            }
            return ajax.eventResponse(this, event);
        });
        if (elementSettings.keypress) {
            $(ajax.element).on('keypress', function(event) {
                return ajax.keypressResponse(this, event);
            });
        }
        if (elementSettings.prevent) {
            $(ajax.element).on(elementSettings.prevent, false);
        }
    };
    Drupal.ajax.WRAPPER_FORMAT = '_wrapper_format';
    Drupal.Ajax.AJAX_REQUEST_PARAMETER = '_drupal_ajax';
    Drupal.Ajax.prototype.execute = function() {
        if (this.ajaxing) {
            return;
        }
        try {
            this.beforeSerialize(this.element, this.options);
            return $.ajax(this.options);
        } catch (e) {
            this.ajaxing = false;
            window.alert("An error occurred while attempting to process ".concat(this.options.url, ": ").concat(e.message));
            return $.Deferred().reject();
        }
    };
    Drupal.Ajax.prototype.keypressResponse = function(element, event) {
        var ajax = this;
        if (event.which === 13 || event.which === 32 && element.type !== 'text' && element.type !== 'textarea' && element.type !== 'tel' && element.type !== 'number') {
            event.preventDefault();
            event.stopPropagation();
            $(element).trigger(ajax.elementSettings.event);
        }
    };
    Drupal.Ajax.prototype.eventResponse = function(element, event) {
        event.preventDefault();
        event.stopPropagation();
        var ajax = this;
        if (ajax.ajaxing) {
            return;
        }
        try {
            if (ajax.$form) {
                if (ajax.setClick) {
                    element.form.clk = element;
                }
                ajax.$form.ajaxSubmit(ajax.options);
            } else {
                ajax.beforeSerialize(ajax.element, ajax.options);
                $.ajax(ajax.options);
            }
        } catch (e) {
            ajax.ajaxing = false;
            window.alert("An error occurred while attempting to process ".concat(ajax.options.url, ": ").concat(e.message));
        }
    };
    Drupal.Ajax.prototype.beforeSerialize = function(element, options) {
        if (this.$form && document.body.contains(this.$form.get(0))) {
            var settings = this.settings || drupalSettings;
            Drupal.detachBehaviors(this.$form.get(0), settings, 'serialize');
        }
        options.data[Drupal.Ajax.AJAX_REQUEST_PARAMETER] = 1;
        var pageState = drupalSettings.ajaxPageState;
        options.data['ajax_page_state[theme]'] = pageState.theme;
        options.data['ajax_page_state[theme_token]'] = pageState.theme_token;
        options.data['ajax_page_state[libraries]'] = pageState.libraries;
    };
    Drupal.Ajax.prototype.beforeSubmit = function(formValues, element, options) {};
    Drupal.Ajax.prototype.beforeSend = function(xmlhttprequest, options) {
        if (this.$form) {
            options.extraData = options.extraData || {};
            options.extraData.ajax_iframe_upload = '1';
            var v = $.fieldValue(this.element);
            if (v !== null) {
                options.extraData[this.element.name] = v;
            }
        }
        $(this.element).prop('disabled', true);
        if (!this.progress || !this.progress.type) {
            return;
        }
        var progressIndicatorMethod = "setProgressIndicator".concat(this.progress.type.slice(0, 1).toUpperCase()).concat(this.progress.type.slice(1).toLowerCase());
        if (progressIndicatorMethod in this && typeof this[progressIndicatorMethod] === 'function') {
            this[progressIndicatorMethod].call(this);
        }
    };
    Drupal.theme.ajaxProgressThrobber = function(message) {
        var messageMarkup = typeof message === 'string' ? Drupal.theme('ajaxProgressMessage', message) : '';
        var throbber = '<div class="throbber">&nbsp;</div>';
        return "<div class=\"ajax-progress ajax-progress-throbber\">".concat(throbber).concat(messageMarkup, "</div>");
    };
    Drupal.theme.ajaxProgressIndicatorFullscreen = function() {
        return '<div class="ajax-progress ajax-progress-fullscreen">&nbsp;</div>';
    };
    Drupal.theme.ajaxProgressMessage = function(message) {
        return "<div class=\"message\">".concat(message, "</div>");
    };
    Drupal.theme.ajaxProgressBar = function($element) {
        return $('<div class="ajax-progress ajax-progress-bar"></div>').append($element);
    };
    Drupal.Ajax.prototype.setProgressIndicatorBar = function() {
        var progressBar = new Drupal.ProgressBar("ajax-progress-".concat(this.element.id), $.noop, this.progress.method, $.noop);
        if (this.progress.message) {
            progressBar.setProgress(-1, this.progress.message);
        }
        if (this.progress.url) {
            progressBar.startMonitoring(this.progress.url, this.progress.interval || 1500);
        }
        this.progress.element = $(Drupal.theme('ajaxProgressBar', progressBar.element));
        this.progress.object = progressBar;
        $(this.element).after(this.progress.element);
    };
    Drupal.Ajax.prototype.setProgressIndicatorThrobber = function() {
        this.progress.element = $(Drupal.theme('ajaxProgressThrobber', this.progress.message));
        $(this.element).after(this.progress.element);
    };
    Drupal.Ajax.prototype.setProgressIndicatorFullscreen = function() {
        this.progress.element = $(Drupal.theme('ajaxProgressIndicatorFullscreen'));
        $('body').append(this.progress.element);
    };
    Drupal.Ajax.prototype.commandExecutionQueue = function(response, status) {
        var _this2 = this;
        var ajaxCommands = this.commands;
        return Object.keys(response || {}).reduce(function(executionQueue, key) {
            return executionQueue.then(function() {
                var command = response[key].command;
                if (command && ajaxCommands[command]) {
                    return ajaxCommands[command](_this2, response[key], status);
                }
            });
        }, Promise.resolve());
    };
    Drupal.Ajax.prototype.success = function(response, status) {
        var _this3 = this;
        if (this.progress.element) {
            $(this.progress.element).remove();
        }
        if (this.progress.object) {
            this.progress.object.stopMonitoring();
        }
        $(this.element).prop('disabled', false);
        var elementParents = $(this.element).parents('[data-drupal-selector]').addBack().toArray();
        var focusChanged = Object.keys(response || {}).some(function(key) {
            var _response$key = response[key],
                command = _response$key.command,
                method = _response$key.method;
            return command === 'focusFirst' || command === 'invoke' && method === 'focus';
        });
        return this.commandExecutionQueue(response, status).then(function() {
            if (!focusChanged && _this3.element && !$(_this3.element).data('disable-refocus')) {
                var target = false;
                for (var n = elementParents.length - 1; !target && n >= 0; n--) {
                    target = document.querySelector("[data-drupal-selector=\"".concat(elementParents[n].getAttribute('data-drupal-selector'), "\"]"));
                }
                if (target) {
                    $(target).trigger('focus');
                }
            }
            if (_this3.$form && document.body.contains(_this3.$form.get(0))) {
                var settings = _this3.settings || drupalSettings;
                Drupal.attachBehaviors(_this3.$form.get(0), settings);
            }
            _this3.settings = null;
        }).catch(function(error) {
            return console.error(Drupal.t('An error occurred during the execution of the Ajax response: !error', {
                '!error': error
            }));
        });
    };
    Drupal.Ajax.prototype.getEffect = function(response) {
        var type = response.effect || this.effect;
        var speed = response.speed || this.speed;
        var effect = {};
        if (type === 'none') {
            effect.showEffect = 'show';
            effect.hideEffect = 'hide';
            effect.showSpeed = '';
        } else if (type === 'fade') {
            effect.showEffect = 'fadeIn';
            effect.hideEffect = 'fadeOut';
            effect.showSpeed = speed;
        } else {
            effect.showEffect = "".concat(type, "Toggle");
            effect.hideEffect = "".concat(type, "Toggle");
            effect.showSpeed = speed;
        }
        return effect;
    };
    Drupal.Ajax.prototype.error = function(xmlhttprequest, uri, customMessage) {
        if (this.progress.element) {
            $(this.progress.element).remove();
        }
        if (this.progress.object) {
            this.progress.object.stopMonitoring();
        }
        $(this.wrapper).show();
        $(this.element).prop('disabled', false);
        if (this.$form && document.body.contains(this.$form.get(0))) {
            var settings = this.settings || drupalSettings;
            Drupal.attachBehaviors(this.$form.get(0), settings);
        }
        throw new Drupal.AjaxError(xmlhttprequest, uri, customMessage);
    };
    Drupal.theme.ajaxWrapperNewContent = function($newContent, ajax, response) {
        return (response.effect || ajax.effect) !== 'none' && $newContent.filter(function(i) {
            return !($newContent[i].nodeName === '#comment' || $newContent[i].nodeName === '#text' && /^(\s|\n|\r)*$/.test($newContent[i].textContent));
        }).length > 1 ? Drupal.theme('ajaxWrapperMultipleRootElements', $newContent) : $newContent;
    };
    Drupal.theme.ajaxWrapperMultipleRootElements = function($elements) {
        return $('<div></div>').append($elements);
    };
    Drupal.AjaxCommands = function() {};
    Drupal.AjaxCommands.prototype = {
        insert: function insert(ajax, response) {
            var $wrapper = response.selector ? $(response.selector) : $(ajax.wrapper);
            var method = response.method || ajax.method;
            var effect = ajax.getEffect(response);
            var settings = response.settings || ajax.settings || drupalSettings;
            var $newContent = $($.parseHTML(response.data, document, true));
            $newContent = Drupal.theme('ajaxWrapperNewContent', $newContent, ajax, response);
            switch (method) {
                case 'html':
                case 'replaceWith':
                case 'replaceAll':
                case 'empty':
                case 'remove':
                    Drupal.detachBehaviors($wrapper.get(0), settings);
                    break;
                default:
                    break;
            }
            $wrapper[method]($newContent);
            if (effect.showEffect !== 'show') {
                $newContent.hide();
            }
            var $ajaxNewContent = $newContent.find('.ajax-new-content');
            if ($ajaxNewContent.length) {
                $ajaxNewContent.hide();
                $newContent.show();
                $ajaxNewContent[effect.showEffect](effect.showSpeed);
            } else if (effect.showEffect !== 'show') {
                $newContent[effect.showEffect](effect.showSpeed);
            }
            if ($newContent.parents('html').length) {
                $newContent.each(function(index, element) {
                    if (element.nodeType === Node.ELEMENT_NODE) {
                        Drupal.attachBehaviors(element, settings);
                    }
                });
            }
        },
        remove: function remove(ajax, response, status) {
            var settings = response.settings || ajax.settings || drupalSettings;
            $(response.selector).each(function() {
                Drupal.detachBehaviors(this, settings);
            }).remove();
        },
        changed: function changed(ajax, response, status) {
            var $element = $(response.selector);
            if (!$element.hasClass('ajax-changed')) {
                $element.addClass('ajax-changed');
                if (response.asterisk) {
                    $element.find(response.asterisk).append(" <abbr class=\"ajax-changed\" title=\"".concat(Drupal.t('Changed'), "\">*</abbr> "));
                }
            }
        },
        alert: function alert(ajax, response, status) {
            window.alert(response.text);
        },
        announce: function announce(ajax, response) {
            if (response.priority) {
                Drupal.announce(response.text, response.priority);
            } else {
                Drupal.announce(response.text);
            }
        },
        redirect: function redirect(ajax, response, status) {
            window.location = response.url;
        },
        css: function css(ajax, response, status) {
            $(response.selector).css(response.argument);
        },
        settings: function settings(ajax, response, status) {
            var ajaxSettings = drupalSettings.ajax;
            if (ajaxSettings) {
                Drupal.ajax.expired().forEach(function(instance) {
                    if (instance.selector) {
                        var selector = instance.selector.replace('#', '');
                        if (selector in ajaxSettings) {
                            delete ajaxSettings[selector];
                        }
                    }
                });
            }
            if (response.merge) {
                $.extend(true, drupalSettings, response.settings);
            } else {
                ajax.settings = response.settings;
            }
        },
        data: function data(ajax, response, status) {
            $(response.selector).data(response.name, response.value);
        },
        focusFirst: function focusFirst(ajax, response, status) {
            var focusChanged = false;
            var container = document.querySelector(response.selector);
            if (container) {
                var tabbableElements = tabbable(container);
                if (tabbableElements.length) {
                    tabbableElements[0].focus();
                    focusChanged = true;
                } else if (isFocusable(container)) {
                    container.focus();
                    focusChanged = true;
                }
            }
            if (ajax.hasOwnProperty('element') && !focusChanged) {
                ajax.element.focus();
            }
        },
        invoke: function invoke(ajax, response, status) {
            var $element = $(response.selector);
            $element[response.method].apply($element, _toConsumableArray(response.args));
        },
        restripe: function restripe(ajax, response, status) {
            $(response.selector).find('> tbody > tr:visible, > tr:visible').removeClass('odd even').filter(':even').addClass('odd').end().filter(':odd').addClass('even');
        },
        update_build_id: function update_build_id(ajax, response, status) {
            document.querySelectorAll("input[name=\"form_build_id\"][value=\"".concat(response.old, "\"]")).forEach(function(item) {
                item.value = response.new;
            });
        },
        add_css: function add_css(ajax, response, status) {
            $('head').prepend(response.data);
        },
        message: function message(ajax, response) {
            var messages = new Drupal.Message(document.querySelector(response.messageWrapperQuerySelector));
            if (response.clearPrevious) {
                messages.clear();
            }
            messages.add(response.message, response.messageOptions);
        },
        add_js: function add_js(ajax, response, status) {
            var parentEl = document.querySelector(response.selector || 'body');
            var settings = ajax.settings || drupalSettings;
            var allUniqueBundleIds = response.data.map(function(script) {
                var uniqueBundleId = script.src + ajax.instanceIndex;
                loadjs(script.src, uniqueBundleId, {
                    async: false,
                    before: function before(path, scriptEl) {
                        Object.keys(script).forEach(function(attributeKey) {
                            scriptEl.setAttribute(attributeKey, script[attributeKey]);
                        });
                        parentEl.appendChild(scriptEl);
                        return false;
                    }
                });
                return uniqueBundleId;
            });
            return new Promise(function(resolve, reject) {
                loadjs.ready(allUniqueBundleIds, {
                    success: function success() {
                        Drupal.attachBehaviors(parentEl, settings);
                        resolve();
                    },
                    error: function error(depsNotFound) {
                        var message = Drupal.t("The following files could not be loaded: @dependencies", {
                            '@dependencies': depsNotFound.join(', ')
                        });
                        reject(message);
                    }
                });
            });
        }
    };
    var stopEvent = function stopEvent(xhr, settings) {
        return xhr.getResponseHeader('X-Drupal-Ajax-Token') === '1' && settings.isInProgress && settings.isInProgress();
    };
    $.extend(true, $.event.special, {
        ajaxSuccess: {
            trigger: function trigger(event, xhr, settings) {
                if (stopEvent(xhr, settings)) {
                    return false;
                }
            }
        },
        ajaxComplete: {
            trigger: function trigger(event, xhr, settings) {
                if (stopEvent(xhr, settings)) {
                    $.active++;
                    return false;
                }
            }
        }
    });
})(jQuery, window, Drupal, drupalSettings, loadjs, window.tabbable);;
/**
 * @file
 * Provides add_assets command for Ajax responses.
 */

(function(window, Drupal) {

    /**
     * Command to add css.
     *
     * Backported from Drupal 10.1 to handle attributes arrays.
     *
     * @param {Drupal.Ajax} [ajax]
     *   {@link Drupal.Ajax} object created by {@link Drupal.ajax}.
     * @param {object} response
     *   The response from the Ajax request.
     * @param {object[]|string} response.data
     *   An array of styles to be added.
     * @param {number} [status]
     *   The XMLHttpRequest status.
     */
    Drupal.AjaxCommands.prototype.add_css = function(ajax, response, status) {
        if (typeof response.data === 'string') {
            $('head').prepend(response.data);
            return;
        }

        const allUniqueBundleIds = response.data.map(function(style) {
            const uniqueBundleId = style.href + ajax.instanceIndex;
            loadjs(style.href, uniqueBundleId, {
                before(path, styleEl) {
                    // This allows all attributes to be added, like media.
                    Object.keys(style).forEach((attributeKey) => {
                        styleEl.setAttribute(attributeKey, style[attributeKey]);
                    });
                },
            });
            return uniqueBundleId;
        });
        // Returns the promise so that the next AJAX command waits on the
        // completion of this one to execute, ensuring the CSS is loaded before
        // executing.
        return new Promise((resolve, reject) => {
            loadjs.ready(allUniqueBundleIds, {
                success() {
                    // All CSS files were loaded. Resolve the promise and let the
                    // remaining commands execute.
                    resolve();
                },
                error(depsNotFound) {
                    const message = Drupal.t(
                        `The following files could not be loaded: @dependencies`, {
                            '@dependencies': depsNotFound.join(', ')
                        },
                    );
                    reject(message);
                },
            });
        });
    };

})(window, Drupal);;
/**
 * @file
 * Extends methods from core/misc/ajax.js.
 */

(function($, window, Drupal, drupalSettings) {

    /**
     * Attempts to find the closest glyphicon progress indicator.
     *
     * @param {jQuery|Element} element
     *   A DOM element.
     *
     * @returns {jQuery}
     *   A jQuery object.
     */
    Drupal.Ajax.prototype.findGlyphicon = function(element) {
        return $(element).closest('.form-item').find('.ajax-progress.glyphicon')
    };

    /**
     * Starts the spinning of the glyphicon progress indicator.
     *
     * @param {jQuery|Element} element
     *   A DOM element.
     * @param {string} [message]
     *   An optional message to display (tooltip) for the progress.
     *
     * @returns {jQuery}
     *   A jQuery object.
     */
    Drupal.Ajax.prototype.glyphiconStart = function(element, message) {
        var $glyphicon = this.findGlyphicon(element);
        if ($glyphicon[0]) {
            $glyphicon.addClass('glyphicon-spin');

            // Add any message as a tooltip to the glyphicon.
            if ($.fn.tooltip && drupalSettings.bootstrap.tooltip_enabled) {
                $glyphicon
                    .removeAttr('data-toggle')
                    .removeAttr('data-original-title')
                    .removeAttr('title')
                    .tooltip('destroy');

                if (message) {
                    $glyphicon.attr('data-toggle', 'tooltip').attr('title', message).tooltip();
                }
            }

            // Append a message for screen readers.
            if (message) {
                $glyphicon.parent().append('<div class="sr-only message">' + message + '</div>');
            }
        }
        return $glyphicon;
    };

    /**
     * Stop the spinning of a glyphicon progress indicator.
     *
     * @param {jQuery|Element} element
     *   A DOM element.
     */
    Drupal.Ajax.prototype.glyphiconStop = function(element) {
        var $glyphicon = this.findGlyphicon(element);
        if ($glyphicon[0]) {
            $glyphicon.removeClass('glyphicon-spin');
            if ($.fn.tooltip && drupalSettings.bootstrap.tooltip_enabled) {
                $glyphicon
                    .removeAttr('data-toggle')
                    .removeAttr('data-original-title')
                    .removeAttr('title')
                    .tooltip('destroy');
            }
        }
    };

    /**
     * Sets the throbber progress indicator.
     */
    Drupal.Ajax.prototype.setProgressIndicatorThrobber = function() {
        var $element = $(this.element);

        // Find an existing glyphicon progress indicator.
        var $glyphicon = this.glyphiconStart($element, this.progress.message);
        if ($glyphicon[0]) {
            this.progress.element = $glyphicon.parent();
            this.progress.glyphicon = true;
            return;
        }

        // Otherwise, add a glyphicon throbber after the element.
        if (!this.progress.element) {
            this.progress.element = $(Drupal.theme('ajaxThrobber'));
        }
        if (this.progress.message) {
            this.progress.element.after('<div class="message">' + this.progress.message + '</div>');
        }

        // If element is an input DOM element type (not :input), append after.
        if ($element.is('input')) {
            $element.after(this.progress.element);
        }
        // Otherwise append the throbber inside the element.
        else {
            $element.append(this.progress.element);
        }
    };


    /**
     * Handler for the form redirection completion.
     *
     * @param {Array.<Drupal.AjaxCommands~commandDefinition>} response
     * @param {number} status
     */
    var success = Drupal.Ajax.prototype.success;
    Drupal.Ajax.prototype.success = function(response, status) {
        if (this.progress.element) {

            // Stop a glyphicon throbber.
            if (this.progress.glyphicon) {
                this.glyphiconStop(this.progress.element);
            }
            // Remove the progress element.
            else {
                this.progress.element.remove();
            }

            // Remove any message set.
            this.progress.element.parent().find('.message').remove();
        }

        // Invoke the original success handler.
        return success.apply(this, [response, status]);
    };

})(jQuery, this, Drupal, drupalSettings);;
(function(Drupal) {

    /**
     * Command to attach data using jQuery's data API.
     *
     * @param {Drupal.Ajax} [ajax]
     *   {@link Drupal.Ajax} object created by {@link Drupal.ajax}.
     * @param {object} response
     *   The response from the Ajax request.
     * @param {string} response.event_name
     *   The event name
     * @param {object} response.data
     *   The value of the event.
     */
    Drupal.AjaxCommands.prototype.gtagEvent = function(ajax, response) {
        gtag('event', response.event_name, response.data)
    }
})(Drupal);;
/**
 * @file
 * Bootstrap Popovers.
 */

var Drupal = Drupal || {};

(function($, Drupal, Bootstrap) {
    "use strict";

    var $document = $(document);

    /**
     * Extend the Bootstrap Popover plugin constructor class.
     */
    Bootstrap.extendPlugin('popover', function(settings) {
        return {
            DEFAULTS: {
                animation: !!settings.popover_animation,
                autoClose: !!settings.popover_auto_close,
                enabled: settings.popover_enabled,
                html: !!settings.popover_html,
                placement: settings.popover_placement,
                selector: settings.popover_selector,
                trigger: settings.popover_trigger,
                title: settings.popover_title,
                content: settings.popover_content,
                delay: parseInt(settings.popover_delay, 10),
                container: settings.popover_container
            }
        };
    });

    /**
     * Bootstrap Popovers.
     *
     * @todo This should really be properly delegated if selector option is set.
     */
    Drupal.behaviors.bootstrapPopovers = {
        $activePopover: null,
        attach: function(context) {
            // Immediately return if popovers are not available.
            if (!$.fn.popover || !$.fn.popover.Constructor.DEFAULTS.enabled) {
                return;
            }

            var _this = this;

            $document
                .on('show.bs.popover', '[data-toggle=popover]', function() {
                    var $trigger = $(this);
                    var popover = $trigger.data('bs.popover');

                    // Only keep track of clicked triggers that we're manually handling.
                    if (popover.options.originalTrigger === 'click') {
                        if (_this.$activePopover && _this.getOption('autoClose') && !_this.$activePopover.is($trigger)) {
                            _this.$activePopover.popover('hide');
                        }
                        _this.$activePopover = $trigger;
                    }
                })
                // Unfortunately, :focusable is only made available when using jQuery
                // UI. While this would be the most semantic pseudo selector to use
                // here, jQuery UI may not always be loaded. Instead, just use :visible
                // here as this just needs some sort of selector here. This activates
                // delegate binding to elements in jQuery so it can work it's bubbling
                // focus magic since elements don't really propagate their focus events.
                // @see https://www.drupal.org/project/bootstrap/issues/3013236
                .on('focus.bs.popover', ':visible', function(e) {
                    var $target = $(e.target);
                    if (_this.$activePopover && _this.getOption('autoClose') && !_this.$activePopover.is($target) && !$target.closest('.popover.in')[0]) {
                        _this.$activePopover.popover('hide');
                        _this.$activePopover = null;
                    }
                })
                .on('click.bs.popover', function(e) {
                    var $target = $(e.target);
                    if (_this.$activePopover && _this.getOption('autoClose') && !$target.is('[data-toggle=popover]') && !$target.closest('.popover.in')[0]) {
                        _this.$activePopover.popover('hide');
                        _this.$activePopover = null;
                    }
                })
                .on('keyup.bs.popover', function(e) {
                    if (_this.$activePopover && _this.getOption('autoClose') && e.which === 27) {
                        _this.$activePopover.popover('hide');
                        _this.$activePopover = null;
                    }
                });

            var elements = $(context).find('[data-toggle=popover]').toArray();
            for (var i = 0; i < elements.length; i++) {
                var $element = $(elements[i]);
                var options = $.extend({}, $.fn.popover.Constructor.DEFAULTS, $element.data());

                // Store the original trigger.
                options.originalTrigger = options.trigger;

                // If the trigger is "click", then we'll handle it manually here.
                if (options.trigger === 'click') {
                    options.trigger = 'manual';
                }

                // Retrieve content from a target element.
                var target = options.target || $element.is('a[href^="#"]') && $element.attr('href');
                var $target = $document.find(target).clone();
                if (!options.content && $target[0]) {
                    $target.removeClass('visually-hidden hidden').removeAttr('aria-hidden');
                    options.content = $target.wrap('<div/>').parent()[options.html ? 'html' : 'text']() || '';
                }

                // Initialize the popover.
                $element.popover(options);

                // Handle clicks manually.
                if (options.originalTrigger === 'click') {
                    // To ensure the element is bound multiple times, remove any
                    // previously set event handler before adding another one.
                    $element
                        .off('click.drupal.bootstrap.popover')
                        .on('click.drupal.bootstrap.popover', function(e) {
                            $(this).popover('toggle');
                            e.preventDefault();
                            e.stopPropagation();
                        });
                }
            }
        },
        detach: function(context) {
            // Immediately return if popovers are not available.
            if (!$.fn.popover || !$.fn.popover.Constructor.DEFAULTS.enabled) {
                return;
            }

            // Destroy all popovers.
            $(context).find('[data-toggle="popover"]')
                .off('click.drupal.bootstrap.popover')
                .popover('destroy');
        },
        getOption: function(name, defaultValue, element) {
            var $element = element ? $(element) : this.$activePopover;
            var options = $.extend(true, {}, $.fn.popover.Constructor.DEFAULTS, ($element && $element.data('bs.popover') || {}).options);
            if (options[name] !== void 0) {
                return options[name];
            }
            return defaultValue !== void 0 ? defaultValue : void 0;
        }
    };

})(window.jQuery, window.Drupal, window.Drupal.bootstrap);;
/**
 * @file
 * Bootstrap Tooltips.
 */

var Drupal = Drupal || {};

(function($, Drupal, Bootstrap) {
    "use strict";

    /**
     * Extend the Bootstrap Tooltip plugin constructor class.
     */
    Bootstrap.extendPlugin('tooltip', function(settings) {
        return {
            DEFAULTS: {
                animation: !!settings.tooltip_animation,
                enabled: settings.tooltip_enabled,
                html: !!settings.tooltip_html,
                placement: settings.tooltip_placement,
                selector: settings.tooltip_selector,
                trigger: settings.tooltip_trigger,
                delay: parseInt(settings.tooltip_delay, 10),
                container: settings.tooltip_container
            }
        };
    });

    /**
     * Bootstrap Tooltips.
     *
     * @todo This should really be properly delegated if selector option is set.
     */
    Drupal.behaviors.bootstrapTooltips = {
        attach: function(context) {
            // Immediately return if tooltips are not available.
            if (!$.fn.tooltip || !$.fn.tooltip.Constructor.DEFAULTS.enabled) {
                return;
            }

            var elements = $(context).find('[data-toggle="tooltip"]').toArray();
            for (var i = 0; i < elements.length; i++) {
                var $element = $(elements[i]);
                var options = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, $element.data());
                $element.tooltip(options);
            }
        },
        detach: function(context) {
            // Immediately return if tooltips are not available.
            if (!$.fn.tooltip || !$.fn.tooltip.Constructor.DEFAULTS.enabled) {
                return;
            }

            // Destroy all tooltips.
            $(context).find('[data-toggle="tooltip"]').tooltip('destroy');
        }
    };

})(window.jQuery, window.Drupal, window.Drupal.bootstrap);;
/*
 * Superfish v1.4.8 - jQuery menu widget
 * Copyright (c) 2008 Joel Birch
 *
 * Dual licensed under the MIT and GPL licenses:
 *  http://www.opensource.org/licenses/mit-license.php
 *  http://www.gnu.org/licenses/gpl.html
 *
 * CHANGELOG: http://users.tpg.com.au/j_birch/plugins/superfish/changelog.txt
 */
/*
 * This is not the original jQuery Superfish plugin.
 * Please refer to the README for more information.
 */

(function($) {
    $.fn.superfish = function(op) {
        var sf = $.fn.superfish,
            c = sf.c,
            $arrow = $(['<span class="', c.arrowClass, '"> &#187;</span>'].join('')),
            over = function() {
                var $$ = $(this),
                    menu = getMenu($$);
                clearTimeout(menu.sfTimer);
                $$.showSuperfishUl().siblings().hideSuperfishUl();
            },
            out = function() {
                var $$ = $(this),
                    menu = getMenu($$),
                    o = sf.op;
                clearTimeout(menu.sfTimer);
                menu.sfTimer = setTimeout(function() {
                    if ($$.children('.sf-clicked').length == 0) {
                        o.retainPath = ($.inArray($$[0], o.$path) > -1);
                        $$.hideSuperfishUl();
                        if (o.$path.length && $$.parents(['li.', o.hoverClass].join('')).length < 1) {
                            over.call(o.$path);
                        }
                    }
                }, o.delay);
            },
            getMenu = function($menu) {
                var menu = $menu.parents(['ul.', c.menuClass, ':first'].join(''))[0];
                sf.op = sf.o[menu.serial];
                return menu;
            },
            addArrow = function($a) {
                $a.addClass(c.anchorClass).append($arrow.clone());
            };

        return this.each(function() {
            var s = this.serial = sf.o.length;
            var o = $.extend({}, sf.defaults, op);
            o.$path = $('li.' + o.pathClass, this).slice(0, o.pathLevels),
                p = o.$path;
            for (var l = 0; l < p.length; l++) {
                p.eq(l).addClass([o.hoverClass, c.bcClass].join(' ')).filter('li:has(ul)').removeClass(o.pathClass);
            }
            sf.o[s] = sf.op = o;

            $('li:has(ul)', this)[($.fn.hoverIntent && !o.disableHI) ? 'hoverIntent' : 'hover'](over, out).each(function() {
                    if (o.autoArrows) addArrow($(this).children('a:first-child, span.nolink:first-child'));
                })
                .not('.' + c.bcClass)
                .hideSuperfishUl();

            var $a = $('a, span.nolink', this);
            $a.each(function(i) {
                var $li = $a.eq(i).parents('li');
                $a.eq(i).focus(function() {
                    over.call($li);
                }).blur(function() {
                    out.call($li);
                });
            });
            o.onInit.call(this);

        }).each(function() {
            var menuClasses = [c.menuClass];
            if (sf.op.dropShadows) {
                menuClasses.push(c.shadowClass);
            }
            $(this).addClass(menuClasses.join(' '));
        });
    };

    var sf = $.fn.superfish;
    sf.o = [];
    sf.op = {};

    sf.c = {
        bcClass: 'sf-breadcrumb',
        menuClass: 'sf-js-enabled',
        anchorClass: 'sf-with-ul',
        arrowClass: 'sf-sub-indicator',
        shadowClass: 'sf-shadow'
    };
    sf.defaults = {
        hoverClass: 'sfHover',
        pathClass: 'overideThisToUse',
        pathLevels: 1,
        delay: 800,
        animation: {
            opacity: 'show'
        },
        speed: 'fast',
        autoArrows: true,
        dropShadows: true,
        disableHI: false, // true disables hoverIntent detection
        onInit: function() {}, // callback functions
        onBeforeShow: function() {},
        onShow: function() {},
        onHide: function() {}
    };
    $.fn.extend({
        hideSuperfishUl: function() {
            var o = sf.op,
                not = (o.retainPath === true) ? o.$path : '';
            o.retainPath = false;
            var $ul = $(['li.', o.hoverClass].join(''), this).add(this).not(not).removeClass(o.hoverClass)
                .children('ul').addClass('sf-hidden');
            o.onHide.call($ul);
            return this;
        },
        showSuperfishUl: function() {
            var o = sf.op,
                sh = sf.c.shadowClass + '-off',
                $ul = this.addClass(o.hoverClass)
                .children('ul.sf-hidden').hide().removeClass('sf-hidden');
            o.onBeforeShow.call($ul);
            $ul.animate(o.animation, o.speed, function() {
                o.onShow.call($ul);
            });
            return this;
        }
    });
})(jQuery);;
/*!
 * hoverIntent v1.8.0 // 2014.06.29 // jQuery v1.9.1+
 * http://cherne.net/brian/resources/jquery.hoverIntent.html
 *
 * You may use hoverIntent under the terms of the MIT license. Basically that
 * means you are free to use hoverIntent as long as this header is left intact.
 * Copyright 2007, 2014 Brian Cherne
 */
(function($) {
    $.fn.hoverIntent = function(handlerIn, handlerOut, selector) {
        var cfg = {
            interval: 100,
            sensitivity: 6,
            timeout: 0
        };
        if (typeof handlerIn === "object") {
            cfg = $.extend(cfg, handlerIn)
        } else {
            if ($.isFunction(handlerOut)) {
                cfg = $.extend(cfg, {
                    over: handlerIn,
                    out: handlerOut,
                    selector: selector
                })
            } else {
                cfg = $.extend(cfg, {
                    over: handlerIn,
                    out: handlerIn,
                    selector: handlerOut
                })
            }
        }
        var cX, cY, pX, pY;
        var track = function(ev) {
            cX = ev.pageX;
            cY = ev.pageY
        };
        var compare = function(ev, ob) {
            ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
            if (Math.sqrt((pX - cX) * (pX - cX) + (pY - cY) * (pY - cY)) < cfg.sensitivity) {
                $(ob).off("mousemove.hoverIntent", track);
                ob.hoverIntent_s = true;
                return cfg.over.apply(ob, [ev])
            } else {
                pX = cX;
                pY = cY;
                ob.hoverIntent_t = setTimeout(function() {
                    compare(ev, ob)
                }, cfg.interval)
            }
        };
        var delay = function(ev, ob) {
            ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
            ob.hoverIntent_s = false;
            return cfg.out.apply(ob, [ev])
        };
        var handleHover = function(e) {
            var ev = $.extend({}, e);
            var ob = this;
            if (ob.hoverIntent_t) {
                ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t)
            }
            if (e.type === "mouseenter") {
                pX = ev.pageX;
                pY = ev.pageY;
                $(ob).on("mousemove.hoverIntent", track);
                if (!ob.hoverIntent_s) {
                    ob.hoverIntent_t = setTimeout(function() {
                        compare(ev, ob)
                    }, cfg.interval)
                }
            } else {
                $(ob).off("mousemove.hoverIntent", track);
                if (ob.hoverIntent_s) {
                    ob.hoverIntent_t = setTimeout(function() {
                        delay(ev, ob)
                    }, cfg.timeout)
                }
            }
        };
        return this.on({
            "mouseenter.hoverIntent": handleHover,
            "mouseleave.hoverIntent": handleHover
        }, cfg.selector)
    }
})(jQuery);;
/*
 * sf-Smallscreen v1.3b - Provides small-screen compatibility for the jQuery Superfish plugin.
 *
 * Developer's note:
 * Built as a part of the Superfish project for Drupal (http://drupal.org/project/superfish)
 * Found any bug? have any cool ideas? contact me right away! http://drupal.org/user/619294/contact
 *
 * jQuery version: 1.3.x or higher.
 *
 * Dual licensed under the MIT and GPL licenses:
 *  http://www.opensource.org/licenses/mit-license.php
 *  http://www.gnu.org/licenses/gpl.html
 */

(function($) {
    $.fn.sfsmallscreen = function(options) {
        options = $.extend({
            mode: 'inactive',
            type: 'accordion',
            breakpoint: 768,
            breakpointUnit: 'px',
            useragent: '',
            title: '',
            addSelected: false,
            menuClasses: false,
            hyperlinkClasses: false,
            excludeClass_menu: '',
            excludeClass_hyperlink: '',
            includeClass_menu: '',
            includeClass_hyperlink: '',
            accordionButton: 1,
            expandText: 'Expand',
            collapseText: 'Collapse'
        }, options);

        // We need to clean up the menu from anything unnecessary.
        function refine(menu) {
            var
                refined = menu.clone(),
                // Things that should not be in the small-screen menus.
                rm = refined.find('span.sf-sub-indicator'),
                // This is a helper class for those who need to add extra markup that shouldn't exist
                // in the small-screen versions.
                rh = refined.find('.sf-smallscreen-remove'),
                // Mega-menus has to be removed too.
                mm = refined.find('ul.sf-multicolumn');
            for (var a = 0; a < rh.length; a++) {
                rh.eq(a).replaceWith(rh.eq(a).html());
            }
            if (options.accordionButton == 2 || options.type == 'select') {
                for (var b = 0; b < rm.length; b++) {
                    rm.eq(b).remove();
                }
            }
            if (mm.length > 0) {
                mm.removeClass('sf-multicolumn');
                var ol = refined.find('div.sf-multicolumn-column > ol');
                for (var o = 0; o < ol.length; o++) {
                    ol.eq(o).replaceWith('<ul>' + ol.eq(o).html() + '</ul>');
                }
                var elements = ['div.sf-multicolumn-column', '.sf-multicolumn-wrapper > ol', 'li.sf-multicolumn-wrapper'];
                for (var i = 0; i < elements.length; i++) {
                    obj = refined.find(elements[i]);
                    for (var t = 0; t < obj.length; t++) {
                        obj.eq(t).replaceWith(obj.eq(t).html());
                    }
                }
                refined.find('.sf-multicolumn-column').removeClass('sf-multicolumn-column');
            }
            refined.add(refined.find('*')).css({
                width: ''
            });
            return refined;
        }

        // Creating <option> elements out of the menu.
        function toSelect(menu, level) {
            var
                items = '',
                childLI = $(menu).children('li');
            for (var a = 0; a < childLI.length; a++) {
                var list = childLI.eq(a),
                    parent = list.children('a, span');
                for (var b = 0; b < parent.length; b++) {
                    var
                        item = parent.eq(b),
                        path = (item.is('a') && !!item.attr('href')) ? item.attr('href') : '',
                        // Class names modification.
                        itemClone = item.clone(),
                        classes = (options.hyperlinkClasses) ? ((options.excludeClass_hyperlink && itemClone.hasClass(options.excludeClass_hyperlink)) ? itemClone.removeClass(options.excludeClass_hyperlink).attr('class') : itemClone.attr('class')) : '',
                        classes = (options.includeClass_hyperlink && !itemClone.hasClass(options.includeClass_hyperlink)) ? ((options.hyperlinkClasses) ? itemClone.addClass(options.includeClass_hyperlink).attr('class') : options.includeClass_hyperlink) : classes;
                    // Retaining the active class if requested.
                    if (options.addSelected && item.hasClass('active')) {
                        classes += ' active';
                    }
                    classes = (classes) ? ' class="' + classes + '"' : '';
                    // <option> has to be disabled if the item is not a link.
                    disable = (path == '') || (path == '#') ? ' disabled="disabled"' : '',
                        // Crystal clear.
                        subIndicator = 1 < level ? Array(level).join('-') + ' ' : '';
                    // Preparing the <option> element.
                    items += '<option value="' + path + '"' + classes + disable + '>' + subIndicator + $.trim(item.text()) + '</option>',
                        childUL = list.find('> ul');
                    // Using the function for the sub-menu of this item.
                    for (var u = 0; u < childUL.length; u++) {
                        items += toSelect(childUL.eq(u), level + 1);
                    }
                }
            }
            return items;
        }

        // Create the new version, hide the original.
        function convert(menu) {
            var menuID = menu.attr('id'),
                // Creating a refined version of the menu.
                refinedMenu = refine(menu);
            // Currently the plugin provides two reactions to small screens.
            // Converting the menu to a <select> element, and converting to an accordion version of the menu.
            if (options.type == 'accordion') {
                var
                    toggleID = menuID + '-toggle',
                    accordionID = menuID + '-accordion';
                // Making sure the accordion does not exist.
                if ($('#' + accordionID).length == 0) {
                    var
                        // Getting the style class.
                        styleClass = menu.attr('class').split(' ').filter(function(item) {
                            return item.indexOf('sf-style-') > -1 ? item : '';
                        }),
                        // Creating the accordion.
                        accordion = $(refinedMenu).attr('id', accordionID);
                    // Removing unnecessary classes.
                    accordion.removeClass('sf-horizontal sf-vertical sf-navbar sf-shadow sf-js-enabled');
                    // Adding necessary classes.
                    accordion.addClass('sf-accordion sf-hidden');
                    // Removing style attributes and any unnecessary class.
                    accordion.find('li').each(function() {
                        $(this).removeAttr('style').removeClass('sfHover').attr('id', $(this).attr('id') + '-accordion');
                    });
                    // Doing the same and making sure all the sub-menus are off-screen (hidden).
                    accordion.children('ul').removeAttr('style').not('.sf-hidden').addClass('sf-hidden');
                    // Creating the accordion toggle switch.
                    var toggle = '<div class="sf-accordion-toggle ' + styleClass + '"><a href="#" id="' + toggleID + '"><span>' + options.title + '</span></a></div>';

                    // Adding Expand\Collapse buttons if requested.
                    if (options.accordionButton == 2) {
                        accordion.addClass('sf-accordion-with-buttons');
                        var parent = accordion.find('li.menuparent');
                        for (var i = 0; i < parent.length; i++) {
                            parent.eq(i).prepend('<a href="#" class="sf-accordion-button">' + options.expandText + '</a>');
                        }
                    }
                    // Inserting the according and hiding the original menu.
                    menu.before(toggle).before(accordion).hide();

                    var
                        accordionElement = $('#' + accordionID),
                        // Deciding what should be used as accordion buttons.
                        buttonElement = (options.accordionButton < 2) ? 'a.menuparent,span.nolink.menuparent' : 'a.sf-accordion-button',
                        button = accordionElement.find(buttonElement);

                    // Attaching a click event to the toggle switch.
                    $('#' + toggleID).on('click', function(e) {
                        // Preventing the click.
                        e.preventDefault();
                        // Adding the sf-expanded class.
                        $(this).toggleClass('sf-expanded');

                        if (accordionElement.hasClass('sf-expanded')) {
                            // If the accordion is already expanded:
                            // Hiding its expanded sub-menus and then the accordion itself as well.
                            accordionElement.add(accordionElement.find('li.sf-expanded')).removeClass('sf-expanded')
                                .end().children('ul').hide()
                                // This is a bit tricky, it's the same trick that has been in use in the main plugin for some time.
                                // Basically we'll add a class that keeps the sub-menu off-screen and still visible,
                                // and make it invisible and removing the class one moment before showing or hiding it.
                                // This helps screen reader software access all the menu items.
                                .end().hide().addClass('sf-hidden').show();
                            // Changing the caption of any existing accordion buttons to 'Expand'.
                            if (options.accordionButton == 2) {
                                accordionElement.find('a.sf-accordion-button').text(options.expandText);
                            }
                        } else {
                            // But if it's collapsed,
                            accordionElement.addClass('sf-expanded').hide().removeClass('sf-hidden').show();
                        }
                    });

                    // Attaching a click event to the buttons.
                    button.on('click', function(e) {
                        // Making sure the buttons does not exist already.
                        if ($(this).closest('li').children('ul').length > 0) {
                            e.preventDefault();
                            // Selecting the parent menu items.
                            var parent = $(this).closest('li');
                            // Creating and inserting Expand\Collapse buttons to the parent menu items,
                            // of course only if not already happened.
                            if (options.accordionButton == 1 && parent.children('a.menuparent,span.nolink.menuparent').length > 0 && parent.children('ul').children('li.sf-clone-parent').length == 0) {
                                var
                                    // Cloning the hyperlink of the parent menu item.
                                    cloneLink = parent.children('a.menuparent,span.nolink.menuparent').clone();
                                // Removing unnecessary classes and element(s).
                                cloneLink.removeClass('menuparent sf-with-ul').children('.sf-sub-indicator').remove();
                                // Wrapping the hyerplinks in <li>.
                                cloneLink = $('<li class="sf-clone-parent" />').html(cloneLink);
                                // Adding a helper class and attaching them to the sub-menus.
                                parent.children('ul').addClass('sf-has-clone-parent').prepend(cloneLink);
                            }
                            // Once the button is clicked, collapse the sub-menu if it's expanded.
                            if (parent.hasClass('sf-expanded')) {
                                parent.children('ul').slideUp('fast', function() {
                                    // Doing the accessibility trick after hiding the sub-menu.
                                    $(this).closest('li').removeClass('sf-expanded').end().addClass('sf-hidden').show();
                                });
                                // Changing the caption of the inserted Collapse link to 'Expand', if any is inserted.
                                if (options.accordionButton == 2 && parent.children('.sf-accordion-button').length > 0) {
                                    parent.children('.sf-accordion-button').text(options.expandText);
                                }
                            }
                            // Otherwise, expand the sub-menu.
                            else {
                                // Doing the accessibility trick and then showing the sub-menu.
                                parent.children('ul').hide().removeClass('sf-hidden').slideDown('fast')
                                    // Changing the caption of the inserted Expand link to 'Collape', if any is inserted.
                                    .end().addClass('sf-expanded').children('a.sf-accordion-button').text(options.collapseText)
                                    // Hiding any expanded sub-menu of the same level.
                                    .end().siblings('li.sf-expanded').children('ul')
                                    .slideUp('fast', function() {
                                        // Doing the accessibility trick after hiding it.
                                        $(this).closest('li').removeClass('sf-expanded').end().addClass('sf-hidden').show();
                                    })
                                    // Assuming Expand\Collapse buttons do exist, resetting captions, in those hidden sub-menus.
                                    .parent().children('a.sf-accordion-button').text(options.expandText);
                            }
                        }
                    });
                }
            } else {
                var
                    // Class names modification.
                    menuClone = menu.clone(),
                    classes = (options.menuClasses) ? ((options.excludeClass_menu && menuClone.hasClass(options.excludeClass_menu)) ? menuClone.removeClass(options.excludeClass_menu).attr('class') : menuClone.attr('class')) : '',
                    classes = (options.includeClass_menu && !menuClone.hasClass(options.includeClass_menu)) ? ((options.menuClasses) ? menuClone.addClass(options.includeClass_menu).attr('class') : options.includeClass_menu) : classes,
                    classes = (classes) ? ' class="' + classes + '"' : '';

                // Making sure the <select> element does not exist already.
                if ($('#' + menuID + '-select').length == 0) {
                    // Creating the <option> elements.
                    var newMenu = toSelect(refinedMenu, 1),
                        // Creating the <select> element and assigning an ID and class name.
                        selectList = $('<select' + classes + ' id="' + menuID + '-select"/>')
                        // Attaching the title and the items to the <select> element.
                        .html('<option>' + options.title + '</option>' + newMenu)
                        // Attaching an event then.
                        .change(function() {
                            // Except for the first option that is the menu title and not a real menu item.
                            if ($('option:selected', this).index()) {
                                window.location = selectList.val();
                            }
                        });
                    // Applying the addSelected option to it.
                    if (options.addSelected) {
                        selectList.find('.active').attr('selected', !0);
                    }
                    // Finally inserting the <select> element into the document then hiding the original menu.
                    menu.before(selectList).hide();
                }
            }
        }

        // Turn everything back to normal.
        function turnBack(menu) {
            var
                id = '#' + menu.attr('id');
            // Removing the small screen version.
            $(id + '-' + options.type).remove();
            // Removing the accordion toggle switch as well.
            if (options.type == 'accordion') {
                $(id + '-toggle').parent('div').remove();
            }
            // Remove inline CSS display property; less clear than simply using .show(), but respects stylesheet
            $(id).css('display', '');
        }

        // Return original object to support chaining.
        // Although this is unnecessary because of the way the module uses these plugins.
        for (var s = 0; s < this.length; s++) {
            var
                menu = $(this).eq(s),
                mode = options.mode;
            // The rest is crystal clear, isn't it? :)
            if (mode == 'always_active') {
                convert(menu);
            } else if (mode == 'window_width') {
                var breakpoint = (options.breakpointUnit == 'em') ? (options.breakpoint * parseFloat($('body').css('font-size'))) : options.breakpoint,
                    windowWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth,
                    timer;
                if ((typeof Modernizr === 'undefined' || typeof Modernizr.mq !== 'function') && windowWidth < breakpoint) {
                    convert(menu);
                } else if (typeof Modernizr !== 'undefined' && typeof Modernizr.mq === 'function' && Modernizr.mq('(max-width:' + (breakpoint - 1) + 'px)')) {
                    convert(menu);
                }
                $(window).resize(function() {
                    clearTimeout(timer);
                    timer = setTimeout(function() {
                        var windowWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
                        if ((typeof Modernizr === 'undefined' || typeof Modernizr.mq !== 'function') && windowWidth < breakpoint) {
                            convert(menu);
                        } else if (typeof Modernizr !== 'undefined' && typeof Modernizr.mq === 'function' && Modernizr.mq('(max-width:' + (breakpoint - 1) + 'px)')) {
                            convert(menu);
                        } else {
                            turnBack(menu);
                        }
                    }, 50);
                });
            } else if (mode == 'useragent_custom') {
                if (options.useragent != '') {
                    var ua = RegExp(options.useragent, 'i');
                    if (navigator.userAgent.match(ua)) {
                        convert(menu);
                    }
                }
            } else if (mode == 'useragent_predefined' && navigator.userAgent.match(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od|ad)|iris|kindle|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i)) {
                convert(menu);
            }
        }
        return this;
    }
})(jQuery);;
/*
 * Supposition v0.2 - an optional enhancer for Superfish jQuery menu widget.
 *
 * Copyright (c) 2008 Joel Birch - based mostly on work by Jesse Klaasse and credit goes largely to him.
 * Special thanks to Karl Swedberg for valuable input.
 *
 * Dual licensed under the MIT and GPL licenses:
 *  http://www.opensource.org/licenses/mit-license.php
 *  http://www.gnu.org/licenses/gpl.html
 */
/*
 * This is not the original jQuery Supposition plugin.
 * Please refer to the README for more information.
 */

(function($) {
    $.fn.supposition = function() {
        var $w = $(window),
            /*do this once instead of every onBeforeShow call*/
            _offset = function(dir) {
                return window[dir == 'y' ? 'pageYOffset' : 'pageXOffset'] ||
                    document.documentElement && document.documentElement[dir == 'y' ? 'scrollTop' : 'scrollLeft'] ||
                    document.body[dir == 'y' ? 'scrollTop' : 'scrollLeft'];
            },
            onHide = function() {
                this.css({
                    bottom: ''
                });
            },
            onBeforeShow = function() {
                this.each(function() {
                    var $u = $(this);
                    $u.css('display', 'block');
                    var $mul = $u.closest('.sf-menu'),
                        level = $u.parents('ul').length,
                        menuWidth = $u.width(),
                        menuParentWidth = $u.closest('li').outerWidth(true),
                        menuParentLeft = $u.closest('li').offset().left,
                        totalRight = $w.width() + _offset('x'),
                        menuRight = $u.offset().left + menuWidth,
                        exactMenuWidth = (menuRight > (menuParentWidth + menuParentLeft)) ? menuWidth - (menuRight - (menuParentWidth + menuParentLeft)) : menuWidth;
                    if ($u.parents('.sf-js-enabled').hasClass('rtl')) {
                        if (menuParentLeft < exactMenuWidth) {
                            if (($mul.hasClass('sf-horizontal') && level == 1) || ($mul.hasClass('sf-navbar') && level == 2)) {
                                $u.css({
                                    left: 0,
                                    right: 'auto'
                                });
                            } else {
                                $u.css({
                                    left: menuParentWidth + 'px',
                                    right: 'auto'
                                });
                            }
                        }
                    } else {
                        if (menuRight > totalRight && menuParentLeft > menuWidth) {
                            if (($mul.hasClass('sf-horizontal') && level == 1) || ($mul.hasClass('sf-navbar') && level == 2)) {
                                $u.css({
                                    right: 0,
                                    left: 'auto'
                                });
                            } else {
                                $u.css({
                                    right: menuParentWidth + 'px',
                                    left: 'auto'
                                });
                            }
                        }
                    }
                    var windowHeight = $w.height(),
                        offsetTop = $u.offset().top,
                        menuParentShadow = ($mul.hasClass('sf-shadow') && $u.css('padding-bottom').length > 0) ? parseInt($u.css('padding-bottom').slice(0, -2)) : 0,
                        menuParentHeight = ($mul.hasClass('sf-vertical')) ? '-' + menuParentShadow : $u.parent().outerHeight(true) - menuParentShadow,
                        menuHeight = $u.height(),
                        baseline = windowHeight + _offset('y');
                    var expandUp = ((offsetTop + menuHeight > baseline) && (offsetTop > menuHeight));
                    if (expandUp) {
                        $u.css({
                            bottom: menuParentHeight + 'px',
                            top: 'auto'
                        });
                    }
                    $u.css('display', 'none');
                });
            };

        return this.each(function() {
            var o = $.fn.superfish.o[this.serial]; /* get this menu's options */

            /* if callbacks already set, store them */
            var _onBeforeShow = o.onBeforeShow,
                _onHide = o.onHide;

            $.extend($.fn.superfish.o[this.serial], {
                onBeforeShow: function() {
                    onBeforeShow.call(this); /* fire our Supposition callback */
                    _onBeforeShow.call(this); /* fire stored callbacks */
                },
                onHide: function() {
                    onHide.call(this); /* fire our Supposition callback */
                    _onHide.call(this); /* fire stored callbacks */
                }
            });
        });
    };
})(jQuery);;
/*
 * Supersubs v0.4b - jQuery plugin
 * Copyright (c) 2013 Joel Birch
 *
 * Dual licensed under the MIT and GPL licenses:
 *  http://www.opensource.org/licenses/mit-license.php
 *  http://www.gnu.org/licenses/gpl.html
 *
 * This plugin automatically adjusts submenu widths of suckerfish-style menus to that of
 * their longest list item children. If you use this, please expect bugs and report them
 * to the jQuery Google Group with the word 'Superfish' in the subject line.
 *
 */
/*
 * This is not the original jQuery Supersubs plugin.
 * Please refer to the README for more information.
 */

(function($) { // $ will refer to jQuery within this closure
    $.fn.supersubs = function(options) {
        var opts = $.extend({}, $.fn.supersubs.defaults, options);
        // return original object to support chaining
        // Although this is unnecessary due to the way the module uses these plugins.
        for (var a = 0; a < this.length; a++) {
            // cache selections
            var $$ = $(this).eq(a),
                // support metadata
                o = $.meta ? $.extend({}, opts, $$.data()) : opts;
            // Jump one level if it's a "NavBar"
            if ($$.hasClass('sf-navbar')) {
                $$ = $$.children('li').children('ul');
            }
            // cache all ul elements
            var $ULs = $$.find('ul'),
                // get the font size of menu.
                // .css('fontSize') returns various results cross-browser, so measure an em dash instead
                fontsize = $('<li id="menu-fontsize">&#8212;</li>'),
                size = fontsize.attr('style', 'padding:0;position:absolute;top:-99999em;width:auto;')
                .appendTo($$)[0].clientWidth; //clientWidth is faster than width()
            // remove em dash
            fontsize.remove();

            // loop through each ul in menu
            for (var b = 0; b < $ULs.length; b++) {
                var
                    // cache this ul
                    $ul = $ULs.eq(b);
                // If a multi-column sub-menu, and only if correctly configured.
                if (o.multicolumn && $ul.hasClass('sf-multicolumn') && $ul.find('.sf-multicolumn-column').length > 0) {
                    // Look through each column.
                    var $column = $ul.find('div.sf-multicolumn-column > ol'),
                        // Overall width.
                        mwWidth = 0;
                    for (var d = 0; d < $column.length; d++) {
                        resize($column.eq(d));
                        // New column width, in pixels.
                        var colWidth = $column.width();
                        // Just a trick to convert em unit to px.
                        $column.css({
                                width: colWidth
                            })
                            // Making column parents the same size.
                            .parents('.sf-multicolumn-column').css({
                                width: colWidth
                            });
                        // Overall width.
                        mwWidth += parseInt(colWidth);
                    }
                    // Resizing the columns container too.
                    $ul.add($ul.find('li.sf-multicolumn-wrapper, li.sf-multicolumn-wrapper > ol')).css({
                        width: mwWidth
                    });
                } else {
                    resize($ul);
                }
            }
        }

        function resize($ul) {
            var
                // get all (li) children of this ul
                $LIs = $ul.children(),
                // get all anchor grand-children
                $As = $LIs.children('a');
            // force content to one line and save current float property
            $LIs.css('white-space', 'nowrap');
            // remove width restrictions and floats so elements remain vertically stacked
            $ul.add($LIs).add($As).css({
                float: 'none',
                width: 'auto'
            });
            // this ul will now be shrink-wrapped to longest li due to position:absolute
            // so save its width as ems.
            var emWidth = $ul.get(0).clientWidth / size;
            // add more width to ensure lines don't turn over at certain sizes in various browsers
            emWidth += o.extraWidth;
            // restrict to at least minWidth and at most maxWidth
            if (emWidth > o.maxWidth) {
                emWidth = o.maxWidth;
            } else if (emWidth < o.minWidth) {
                emWidth = o.minWidth;
            }
            emWidth += 'em';
            // set ul to width in ems
            $ul.css({
                width: emWidth
            });
            // restore li floats to avoid IE bugs
            // set li width to full width of this ul
            // revert white-space to normal
            $LIs.add($As).css({
                float: '',
                width: '',
                whiteSpace: ''
            });
            // update offset position of descendant ul to reflect new width of parent.
            // set it to 100% in case it isn't already set to this in the CSS
            for (var c = 0; c < $LIs.length; c++) {
                var $childUl = $LIs.eq(c).children('ul');
                var offsetDirection = $childUl.css('left') !== undefined ? 'left' : 'right';
                $childUl.css(offsetDirection, '100%');
            }
        }
        return this;
    };
    // expose defaults
    $.fn.supersubs.defaults = {
        multicolumn: true, // define width for multi-column sub-menus and their columns.
        minWidth: 12, // requires em unit.
        maxWidth: 27, // requires em unit.
        extraWidth: 1 // extra width can ensure lines don't sometimes turn over due to slight browser differences in how they round-off values
    };
})(jQuery); // plugin code ends
;
/**
 * @file
 * The Superfish Drupal Behavior to apply the Superfish jQuery plugin to lists.
 */

(function($, Drupal, drupalSettings) {

    'use strict';

    /**
     * jQuery Superfish plugin.
     *
     * @type {Drupal~behavior}
     *
     * @prop {Drupal~behaviorAttach} attach
     *   Attaches the behavior to an applicable <ul> element.
     */
    Drupal.behaviors.superfish = {
        attach: function(context, drupalSettings) {
            // Take a look at each menu to apply Superfish to.
            $.each(drupalSettings.superfish || {}, function(index, options) {
                var $menu = $('ul#' + options.id, context);

                // Check if we are to apply the Supersubs plug-in to it.
                if (options.plugins || false) {
                    if (options.plugins.supersubs || false) {
                        $menu.supersubs(options.plugins.supersubs);
                    }
                }

                // Apply Superfish to the menu.
                $menu.superfish(options.sf);

                // Check if we are to apply any other plug-in to it.
                if (options.plugins || false) {
                    if (options.plugins.touchscreen || false) {
                        $menu.sftouchscreen(options.plugins.touchscreen);
                    }
                    if (options.plugins.smallscreen || false) {
                        $menu.sfsmallscreen(options.plugins.smallscreen);
                    }
                    if (options.plugins.supposition || false) {
                        $menu.supposition();
                    }
                }
            });
        }
    };
})(jQuery, Drupal, drupalSettings);;